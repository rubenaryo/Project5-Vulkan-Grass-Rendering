#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WORKGROUP_SIZE 32
layout(local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform CameraBufferObject {
    mat4 view;
    mat4 proj;
} camera;

layout(set = 1, binding = 0) uniform Time {
    float deltaTime;
    float totalTime;
};

struct Blade {
    vec4 v0;
    vec4 v1;
    vec4 v2;
    vec4 up;
};

// Add bindings to:
// 1. Store the input blades
// 2. Write out the culled blades
// 3. Write the total number of blades remaining

layout(set = 2, binding = 0) buffer Blades {
    Blade blades[];
};

layout(set = 2, binding = 1) buffer CulledBlades {
    Blade culledBlades[];
};

layout(set = 2, binding = 2) buffer NumBlades {
    uint vertexCount;
    uint instanceCount;
    uint firstVertex;
    uint firstInstance;
} numBlades;


bool inBounds(float value, float bounds) {
    return (value >= -bounds) && (value <= bounds);
}

vec3 computeGravity(vec3 bladeNormal)
{
    const float ENV_GRAVITY_MAG = 9.81;
    
    vec4 D = vec4(0, -1, 0, ENV_GRAVITY_MAG);
    vec3 gE = normalize(D.xyz) * D.w;
    vec3 gF = 0.25 * length(gE) * bladeNormal;

    return gE + gF;
}

vec3 computeWindInfluence(vec3 v0, float time)
{
    vec3 windDir = normalize(vec3(1.0, 0.0, 0.3));
    
    // Stack sin/cos waves
    float wave1 = sin(v0.x * 0.5 + time * 2.0) * cos(v0.z * 0.3 + time * 1.5);
    float wave2 = sin(v0.x * 0.3 + v0.z * 0.4 + time * 1.2) * 0.5;
    float wave3 = cos(v0.x * 0.7 + time * 0.8) * sin(v0.z * 0.6 + time * 1.0) * 0.3;
    
    float windStrength = wave1 + wave2 + wave3;
    
    float BASE_STRENGTH = 0.5;
    windStrength = windStrength * BASE_STRENGTH;
    return windDir * windStrength;
}

vec3 computeWind(vec3 v0, vec3 v1, vec3 v2, vec3 up, float bladeHeight)
{
    const float TIME_MULTIPLIER = 1.0;
    float t = totalTime * TIME_MULTIPLIER;
    vec3 bladeDir = normalize(v2 - v0);

    vec3 wi = computeWindInfluence(v0, t);

    float fd = 1.0 - abs(dot(normalize(wi), bladeDir)); // alignment
    float fr = dot(v2 - v0, up) / bladeHeight; // height ratio
    float theta = fd * fr;

    return wi * theta;
}

vec3 computeRecovery(vec3 v0, vec3 v2, vec3 up, float bladeHeight, float bladeStiffness)
{
    vec3 baseV2 = v0 + up*bladeHeight;
    return (baseV2 - v2) * bladeStiffness;
}

void stateValidation(vec3 up, float bladeHeight, vec3 v0, in out vec3 v1, in out vec3 v2)
{
    // Ensure v2 is above ground.
    v2 = v2 - up * min(dot(up, v2-v0), 0.0);

    float l_proj = length(v2 - v0 - up * (dot(v2-v0, up)));
    float l_projOverHeight = l_proj / bladeHeight;

    v1 = v0 + bladeHeight*up*max(1.0 - l_projOverHeight, 0.05*max(l_projOverHeight, 1.0));

    float L0 = length(v2-v0);
    float L1 = length(v1-v0) + length(v2-v1);

    float L = (2.0 * L0 + L1) * 0.333;
    float r = bladeHeight / L;

    vec3 v1_corr = v0 + r * (v1-v0);
    vec3 v2_corr = v1_corr + r * (v2-v1);

    v1 = v1_corr;
    v2 = v2_corr;
}

void applyForces(in out Blade blade)
{
    vec3 v0 = blade.v0.xyz; 
    vec3 v1 = blade.v1.xyz;
    vec3 v2 = blade.v2.xyz;
    vec3 up = normalize(blade.up.xyz);

    float bladeAngle = blade.v0.w;
    float bladeHeight = blade.v1.w;
    float bladeWidth = blade.v2.w;
    float bladeStiffness = blade.up.w;

    vec3 bitangent = vec3(-cos(bladeAngle), 0.0, sin(bladeAngle));
    vec3 bladeNormal = cross(up, bitangent);

    vec3 gravity = computeGravity(bladeNormal);
    vec3 wind = computeWind(v0, v1, v2, up, bladeHeight);
    vec3 recovery = computeRecovery(v0, v2, up, bladeHeight, bladeStiffness);

    vec3 allForces = gravity + wind + recovery;
    v2 += allForces * deltaTime;

    stateValidation(up, bladeHeight, v0, v1, v2);

    blade.v2.xyz = v2;
}

bool clipDiscard(vec3 ndc)
{
    const float TOLERANCE = 1.1;

    return ndc.x < -TOLERANCE || ndc.x > TOLERANCE ||
           ndc.y < -TOLERANCE || ndc.y > TOLERANCE ||
           ndc.z <  -0.1 || ndc.z > TOLERANCE;
}

#define ORIENTATION 1
#define FRUSTUM 1
#define DISTANCE 1

bool cullBlade(Blade blade)
{
    mat4 invView = inverse(camera.view);
    vec4 camPos = invView * vec4(0,0,0,1);
    vec3 fromCam = blade.v0.xyz - camPos.xyz;

    float bladeAngle = blade.v0.w;
    vec3 bitangent = vec3(-cos(bladeAngle), 0.0, sin(bladeAngle));
    vec3 bladeNormal = normalize(cross(bitangent, blade.up.xyz));

    // Orientation Cull
    #if ORIENTATION
    const float EPSILON = 0.1;
    if (abs(dot(bladeNormal, normalize(-fromCam))) < EPSILON)
        return true;
    #endif

    // Frustum Cull
    vec4 m = 0.25 * blade.v0 + 0.5 * blade.v1 + 0.25 * blade.v2;

    vec4 v0_clip = camera.proj * camera.view * vec4(blade.v0.xyz, 1.0);
    vec3 v0_ndc  = v0_clip.xyz / v0_clip.w;

    vec4 v2_clip = camera.proj * camera.view * vec4(blade.v2.xyz, 1.0);
    vec3 v2_ndc  = v2_clip.xyz / v2_clip.w;

    vec4 m_clip = camera.proj * camera.view * vec4(m.xyz, 1.0);
    vec3 m_ndc  = m_clip.xyz / m_clip.w;

    #if FRUSTUM
    if (clipDiscard(v0_ndc) && clipDiscard(v2_ndc) && clipDiscard(m_ndc))
        return true;
    #endif

    // Distance Cull
    const float MAX_DIST = 25.0;

    vec3 up = blade.up.xyz;
    vec3 d_proj = fromCam - up*dot(fromCam, up); // fromCam projected onto plane
    float dist = length(d_proj);
    #if DISTANCE
    if (dist > MAX_DIST)
        return true;

    uint NUM_BUCKETS = 4; // n
    float rhs = floor(float(NUM_BUCKETS) * (1.0 - dist/MAX_DIST));
    float idModN = mod(gl_GlobalInvocationID.x, NUM_BUCKETS);

    if (idModN > rhs)
        return true;
    #endif

    return false;
}

void main() {
	// Reset the number of blades to 0
	if (gl_GlobalInvocationID.x == 0) {
		 numBlades.vertexCount = 0;
	}
	barrier(); // Wait till all threads reach this point

    // Apply forces on every blade and update the vertices in the buffer
    Blade blade = blades[gl_GlobalInvocationID.x];
    applyForces(blade);
    blades[gl_GlobalInvocationID.x] = blade;

	// Cull blades that are too far away or not in the camera frustum and write them
	// to the culled blades buffer
    if (cullBlade(blade))
        return;

	// Note: to do this, you will need to use an atomic operation to read and update numBlades.vertexCount
	// You want to write the visible blades to the buffer without write conflicts between threads
    const uint index = atomicAdd(numBlades.vertexCount, 1);
    culledBlades[index] = blade;
}
